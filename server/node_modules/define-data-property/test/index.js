'use strict';

import test from 'tape';
import v from 'es-value-fixtures';
import forEach from 'for-each';
import hasOwn from 'hasown';
import hasPropertyDescriptors from 'has-property-descriptors';
import getOwnPropertyDescriptors from 'object.getownpropertydescriptors';
import ownKeys from 'reflect.ownkeys';
import { defineDataProperty } from '..';

test('defineDataProperty', (t) => {
  t.test('argument validation', (st) => {
    const nonObject = v.primitives.map((nonObject) => () =>
      defineDataProperty(nonObject, 'key', 'value')
    );
    const nonPropertyKey = v.nonPropertyKeys.map((nonPropertyKey) => () =>
      defineDataProperty({}, nonPropertyKey, 'value')
    );
    const nonBoolean = v.nonBooleans.map((nonBoolean) => {
      if (nonBoolean !== null) {
        return () =>
          defineDataProperty(
            {},
            'key',
            'value',
            nonBoolean as any,
            false as any,
            false as any
          );
      }
    });

    st.test(
      'throws on non-object input',
      function () {
        nonObject.every((fn) =>
          st['throws'](fn, TypeError, 'throws on non-object input')
        );
      }
    );

    st.test(
      'throws on non-PropertyKey input',
      function () {
        nonPropertyKey.every((fn) =>
          st['throws'](fn, TypeError, 'throws on non-PropertyKey input')
        );
      }
    );

    st.test(
      'throws on non-boolean nonEnumerable, nonWritable, nonConfigurable',
      function () {
        nonBoolean.every((fn) =>
          st['throws'](fn, TypeError, 'throws on non-boolean input')
        );
      }
    );

    st.end();
  });

  // ... rest of the code ...
});
