"use strict";

import * as zlib from "zlib";
import { sparseBitfield } from "sparse-bitfield";
import { unassigned_code_points, commonly_mapped_to_nothing, non_ascii_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l } from "./code-points-src";
import * as fs from "fs";

const unassignedCodePoints = sparseBitfield();
const commonlyMappedToNothing = sparseBitfield();
const nonAsciiSpaceCharacters = sparseBitfield();
const prohibitedCharacters = sparseBitfield();
const bidirectionalRAl = sparseBitfield();
const bidirectionalL = sparseBitfield();

const traverse = (bits: sparseBitfield, src: Map<number, boolean>) => {
  for (const code of src.keys()) {
    bits.set(code, true);
  }
  const buffer = bits.toBuffer();
  return Buffer.concat([createSize(buffer), buffer]);
};

const createSize = (buffer: Buffer) => {
  const buf = Buffer.alloc(4);
  buf.writeUInt32BE(buffer.length);
  return buf;
};

const memory = [
  traverse(unassignedCodePoints, unassigned_code_points),
  traverse(commonlyMappedToNothing, commonly_mapped_to_nothing),
  traverse(nonAsciiSpaceCharacters, non_ascii_space_characters),
  traverse(prohibitedCharacters, prohibited_characters),
  traverse(bidirectionalRAl, bidirectional_r_al),
  traverse(bidirectionalL, bidirectional_l),
];

const writeFile = (path: string, data: Buffer) => {
  return new Promise((resolve, reject) => {
    const fsStream = fs.createWriteStream(path);
    fsStream.on("error", reject);
    fsStream.on("finish", resolve);
    fsStream.write(data);
    return fsStream.end();
  });
};

(async () => {
  if (!process.env.GENERATE_CODE_POINTS) {
    process.exitCode = 0;
    process.exit();
  }

  try {
    await Promise.all([
      writeFile(process.argv[2], zlib.gzipSync(Buffer.concat(memory), { level: 9 })),
      writeFile(process.argv[3], Buffer.concat(memory)),
    ]);
  } catch (error) {
    console.error("Error writing files:", error);
    process.exitCode = 1;
  }
})();
