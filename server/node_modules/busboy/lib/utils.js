type ContentTypeParams = { [key: string]: string };
type ContentType = { type: string; subtype: string; params: ContentTypeParams };
type DispositionParams = { [key: string]: string };
type Disposition = { type: string; params: DispositionParams };

const TOKEN_REGEX = /[\t\f ]/;
const PARAM_REGEX = /([^;=]+)=("([^"]*)"|([^;]*))/;
const QDTEXT_REGEX = /[^\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x3B\x3C\x3E-\x7E]+/;
const CHARSET_REGEX = /^[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x3B\x3C\x3E-\x7E]+$/;
const EXTENDED_VALUE_REGEX = /^[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x3B\x3C\x3E-\x5B\x5D-\x7E]+$/;
const HEX_VALUES_REGEX = /^[0-9A-Fa-f]$/;

function isToken(charCode: number): boolean {
  return TOKEN_REGEX.test(String.fromCharCode(charCode));
}

function parseParam(str: string): [string, string] {
  const match = PARAM_REGEX.exec(str);
  if (!match) {
    throw new Error(`Invalid parameter: ${str}`);
  }
  const name = match[1].toLowerCase();
  let value = match[3] || match[4];
  if (!value) {
    throw new Error(`Invalid parameter value: ${str}`);
  }
  return [name, value];
}

function parseContentType(str: string): ContentType {
  if (str.length === 0) {
    throw new Error('Content type cannot be empty');
  }

  let i = 0;

  // Parse type
  for (; i < str.length; ++i) {
    if (!isToken(str.charCodeAt(i))) {
      if (str.charCodeAt(i) !== 47 /* '/' */ || i === 0) {
        throw new Error(`Invalid content type: ${str}`);
      }
      break;
    }
  }
  // Check for type without subtype
  if (i === str.length) {
    throw new Error(`Invalid content type: ${str}`);
  }

  const type = str.slice(0, i).toLowerCase();

  // Parse subtype
  const subtypeStart = ++i;
  for (; i < str.length; ++i) {
    if (!isToken(str.charCodeAt(i))) {
      // Make sure we have a subtype
      if (i === subtypeStart) {
        throw new Error(`Invalid content type: ${str}`);
      }

      const params: ContentTypeParams = {};
      if (parseContentTypeParams(str, i, params) === undefined) {
        throw new Error(`Invalid content type: ${str}`);
      }
      break;
    }
  }
  // Make sure we have a subtype
  if (i === subtypeStart) {
    throw new Error(`Invalid content type: ${str}`);
  }

  const subtype = str.slice(subtypeStart, i).toLowerCase();

  const params: ContentTypeParams = {};
  if (parseContentTypeParams(str, i, params) !== undefined) {
    throw new Error(`Invalid content type: ${str}`);
  }

  return { type, subtype, params };
}

function parseContentTypeParams(str: string, i: number, params: ContentTypeParams): void {
  while (i < str.length) {
    // Consume whitespace
    for (; i < str.length; ++i) {
      if (!TOK
