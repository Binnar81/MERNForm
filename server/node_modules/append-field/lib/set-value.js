function valueType(value) {
  if (value === undefined) return 'undefined';
  if (Array.isArray(value)) return 'array';
  if (typeof value === 'object') return 'object';
  return 'scalar';
}

function setLastValue(context, step, currentValue, entryValue) {
  switch (valueType(currentValue)) {
    case 'undefined':
      if (step.append) {
        context[step.key] = [entryValue];
      } else {
        context[step.key] = entryValue;
      }
      break;
    case 'array':
      currentValue.push(entryValue);
      break;
    case 'object':
      setLastValue(currentValue, { type: 'object', key: '', last: true }, currentValue[''], entryValue);
      break;
    case 'scalar':
      currentValue = [currentValue, entryValue];
      break;
    default:
      throw new Error('Invalid currentValue type in setLastValue');
  }

  return context;
}

function setValue(context, step) {
  const { key, nextType } = step;
  let currentValue = context[key];

  if (valueType(currentValue) === 'undefined') {
    if (nextType === 'array') {
      currentValue = [];
    } else {
      currentValue = Object.create(null);
    }

    context[key] = currentValue;
  } else if (valueType(currentValue) === 'object') {
    // do nothing
  } else if (nextType === 'array' && valueType(currentValue) === 'array') {
    // do nothing
  } else if (nextType === 'object') {
    currentValue = Object.create(null);
    context[key] = currentValue;

    for (const [i, item] of currentValue.entries()) {
      if (item !== undefined) {
        currentValue[i] = item;
      }
    }
  } else if (nextType === 'scalar') {
    currentValue = Object.create(null);
    currentValue[''] = currentValue;
    context[key] = currentValue;
  } else {
    throw new Error(`Invalid nextType "${nextType}" in setValue`);
  }

  if (step.last) {
    return setLastValue(context, step, currentValue, step.entryValue
