import { BSONValue, BSONType } from './bson_value';
import type { EJSONOptions } from './extended_json';
import { type InspectFn, defaultInspect } from './parser/utils';

/**
 * A class representation of the BSON Double type.
 * @public
 * @category BSONType
 */
export class Double extends BSONValue {
  private _value!: number;

  get _bsontype(): BSONType {
    return 'Double';
  }

  /**
   * Create a Double type
   *
   * @param value - the number we want to represent as a double.
   */
  constructor(value: number | null = 0) {
    super();
    if (value instanceof Number) {
      value = value.valueOf();
    }

    this._value = +value;
  }

  /**
   * Access the number value.
   *
   * @returns returns the wrapped double number.
   */
  public valueOf(): number {
    return this._value;
  }

  public toJSON(): number {
    return this._value;
  }

  public toString(radix?: number): string {
    return this._value.toString(radix);
  }

  /** @internal */
  public toExtendedJSON(options?: EJSONOptions): number | DoubleExtended {
    if (options && (options.legacy || (options.relaxed && isFinite(this._value)))) {
      return this._value;
    }

    const output = {
      $numberDouble: Number.isInteger(this._value) ? this._value.toFixed(1) : this._value.toString()
    };

    if (Object.is(Math.sign(this._value), -0)) {
      // NOTE: JavaScript has +0 and -0, apparently to model limit calculations. If a user
      // explicitly provided `-0` then we need to ensure the sign makes it into the output
      output.$numberDouble = '-0.0';
    }

    return output;
  }

  /** @internal */
  public static fromExtendedJSON(doc: DoubleExtended, options?: EJSONOptions): number | Double {
    const doubleValue = parseFloat(doc.$numberDouble);
    return options && options.relaxed ? doubleValue : new Double(doubleValue);
  }

  public inspect(depth?: number, options?: unknown, inspect?: InspectFn): string {
    inspect ??= defaultInspect;
    return `new Double(${inspect(this._value, options)})`;
  }
}
